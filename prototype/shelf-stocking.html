<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dunkin' - Konbini Simulator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #2d2d44 0%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            color: #eee;
        }
        h1 {
            margin-bottom: 10px;
            color: #ffd93d;
        }
        .instructions {
            margin-bottom: 15px;
            color: #aaa;
            font-size: 14px;
        }
        canvas {
            border: 3px solid #8b7355;
            border-radius: 8px;
            background: #f5e6d3;
        }
        .status {
            margin-top: 15px;
            font-size: 18px;
            color: #6bcb77;
        }
        .hint {
            margin-top: 10px;
            color: #666;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>Dunkin' - Konbini Simulator</h1>
    <div class="instructions">Arrow Keys / Left Stick = Move | E / X Button = Checkout / Stock | Space / Square = Load items | M / Options = Music</div>
    <canvas id="game" width="640" height="480"></canvas>
    <div class="status" id="status">Sales: $0 | Shelves need stock!</div>
    <div class="hint">Customers shop the shelves, then head to the register. Check them out with E!</div>
    <div id="controllerStatus" style="margin-top: 10px; color: #666; font-size: 12px;"></div>
    <button id="musicBtn" onclick="toggleMusic(); updateMusicButton();" style="margin-top: 10px; padding: 10px 20px; background: #4a4a6a; color: #fff; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">ðŸŽµ Play Music (M)</button>

    <script>
        // ============================================
        // DUNKIN' KONBINI SIMULATOR v8.0
        // Full shopping loop: Browse â†’ Shop â†’ Checkout
        // ============================================

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        // Audio context for progressive sounds
        let audioCtx = null;
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Play a beep at given frequency
        function playTone(freq, duration = 0.1, type = 'square') {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.value = 0.15;
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        // Play progressive tone based on shelf fill (1-10)
        function playShelfTone(count) {
            const freq = 220 + (count * 50);
            playTone(freq, 0.12, 'square');
        }

        // Play completion sound (ka-ching!)
        function playComplete() {
            setTimeout(() => playTone(523, 0.1, 'sine'), 0);
            setTimeout(() => playTone(659, 0.1, 'sine'), 80);
            setTimeout(() => playTone(784, 0.15, 'sine'), 160);
            setTimeout(() => playTone(1047, 0.3, 'sine'), 240);
        }

        // Play pickup sound
        function playPickup() {
            playTone(330, 0.08, 'triangle');
        }

        // Play cash register sound
        function playCashRegister() {
            setTimeout(() => playTone(800, 0.05, 'square'), 0);
            setTimeout(() => playTone(1000, 0.05, 'square'), 50);
            setTimeout(() => playTone(1200, 0.1, 'sine'), 100);
            setTimeout(() => playTone(1600, 0.15, 'sine'), 150);
        }

        // Play item grab sound
        function playGrab() {
            playTone(440, 0.06, 'triangle');
        }

        // ============================================
        // UPBEAT KONBINI MUSIC GENERATOR
        // ============================================

        let musicPlaying = false;
        let musicNodes = {};
        let musicTimeouts = [];

        const BPM = 128;
        const BEAT_TIME = 60 / BPM;

        const NOTES = {
            C3: 130.81, D3: 146.83, E3: 164.81, G3: 196.00, A3: 220.00,
            C4: 261.63, D4: 293.66, E4: 329.63, G4: 392.00, A4: 440.00,
            C5: 523.25, D5: 587.33, E5: 659.25, G5: 783.99, A5: 880.00,
        };

        const CHORD_PROGRESSION = [
            { root: 'C', notes: [NOTES.C3, NOTES.E3, NOTES.G3] },
            { root: 'G', notes: [NOTES.G3, NOTES.D4, NOTES.G4] },
            { root: 'A', notes: [NOTES.A3, NOTES.C4, NOTES.E4] },
            { root: 'F', notes: [NOTES.G3, NOTES.C4, NOTES.E4] },
        ];

        const HAPPY_MELODIES = [
            ['C5', 'E5', 'G5', 'E5', 'C5', 'D5', 'E5', 'G5'],
            ['G5', 'E5', 'D5', 'C5', 'D5', 'E5', 'G5', 'A5'],
            ['E5', 'G5', 'A5', 'G5', 'E5', 'D5', 'C5', 'E5'],
            ['C5', 'C5', 'G4', 'G4', 'A4', 'A4', 'G4', null],
        ];

        const BASS_PATTERN = [1, 0, 1, 0, 1, 1, 0, 1];

        function createMusicContext() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioCtx;
        }

        function scheduleTimeout(fn, time) {
            const id = setTimeout(fn, time);
            musicTimeouts.push(id);
            return id;
        }

        function startMusic() {
            if (musicPlaying) return;

            const ctx = createMusicContext();
            musicPlaying = true;
            musicTimeouts = [];

            const masterGain = ctx.createGain();
            masterGain.gain.value = 0.35;
            masterGain.connect(ctx.destination);
            musicNodes.master = masterGain;

            const convolver = ctx.createConvolver();
            const sampleRate = ctx.sampleRate;
            const length = sampleRate * 0.5;
            const impulse = ctx.createBuffer(2, length, sampleRate);

            for (let channel = 0; channel < 2; channel++) {
                const data = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3);
                }
            }
            convolver.buffer = impulse;

            const dryGain = ctx.createGain();
            const wetGain = ctx.createGain();
            dryGain.gain.value = 0.85;
            wetGain.gain.value = 0.15;

            dryGain.connect(masterGain);
            convolver.connect(wetGain);
            wetGain.connect(masterGain);

            musicNodes.dry = dryGain;
            musicNodes.wet = convolver;

            startChordLayer(ctx, dryGain);
            startMelodyLayer(ctx, dryGain, convolver);
            startBassLayer(ctx, dryGain);
            startDrumLayer(ctx, dryGain);
            startArpLayer(ctx, dryGain, convolver);

            console.log('ðŸŽµ Happy konbini music started!');
        }

        function startChordLayer(ctx, output) {
            let chordIndex = 0;

            function playChord() {
                if (!musicPlaying) return;

                const chord = CHORD_PROGRESSION[chordIndex];

                chord.notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();

                    osc.type = 'triangle';
                    osc.frequency.value = freq * 2;

                    osc.connect(gain);
                    gain.connect(output);

                    const now = ctx.currentTime;
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.08, now + 0.02);
                    gain.gain.linearRampToValueAtTime(0.05, now + BEAT_TIME * 2);
                    gain.gain.linearRampToValueAtTime(0, now + BEAT_TIME * 4 - 0.05);

                    osc.start(now);
                    osc.stop(now + BEAT_TIME * 4);
                });

                chordIndex = (chordIndex + 1) % CHORD_PROGRESSION.length;
                scheduleTimeout(playChord, BEAT_TIME * 4 * 1000);
            }

            playChord();
        }

        function startMelodyLayer(ctx, dry, wet) {
            let patternIndex = 0;
            let noteIndex = 0;

            function playNote() {
                if (!musicPlaying) return;

                const pattern = HAPPY_MELODIES[patternIndex];
                const noteName = pattern[noteIndex];

                if (noteName && NOTES[noteName]) {
                    const freq = NOTES[noteName];

                    const osc = ctx.createOscillator();
                    const osc2 = ctx.createOscillator();
                    const gain = ctx.createGain();
                    const filter = ctx.createBiquadFilter();

                    osc.type = 'square';
                    osc.frequency.value = freq;

                    osc2.type = 'sine';
                    osc2.frequency.value = freq;

                    filter.type = 'lowpass';
                    filter.frequency.value = 3000;
                    filter.Q.value = 2;

                    const oscGain = ctx.createGain();
                    oscGain.gain.value = 0.3;
                    const osc2Gain = ctx.createGain();
                    osc2Gain.gain.value = 0.7;

                    osc.connect(oscGain);
                    osc2.connect(osc2Gain);
                    oscGain.connect(filter);
                    osc2Gain.connect(filter);
                    filter.connect(gain);
                    gain.connect(dry);
                    gain.connect(wet);

                    const now = ctx.currentTime;
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.1, now + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + BEAT_TIME * 0.8);

                    filter.frequency.setValueAtTime(4000, now);
                    filter.frequency.exponentialRampToValueAtTime(1500, now + 0.1);

                    osc.start(now);
                    osc2.start(now);
                    osc.stop(now + BEAT_TIME);
                    osc2.stop(now + BEAT_TIME);
                }

                noteIndex++;
                if (noteIndex >= pattern.length) {
                    noteIndex = 0;
                    patternIndex = (patternIndex + 1) % HAPPY_MELODIES.length;
                }

                scheduleTimeout(playNote, BEAT_TIME * 0.5 * 1000);
            }

            scheduleTimeout(playNote, BEAT_TIME * 4 * 1000);
        }

        function startBassLayer(ctx, output) {
            let chordIndex = 0;
            let beatIndex = 0;

            function playBass() {
                if (!musicPlaying) return;

                if (BASS_PATTERN[beatIndex]) {
                    const chord = CHORD_PROGRESSION[chordIndex];
                    const freq = chord.notes[0];

                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    const filter = ctx.createBiquadFilter();

                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    filter.type = 'lowpass';
                    filter.frequency.value = 500;

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(output);

                    const now = ctx.currentTime;
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.15, now + 0.08);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + BEAT_TIME * 0.4);

                    osc.start(now);
                    osc.stop(now + BEAT_TIME * 0.5);
                }

                beatIndex++;
                if (beatIndex >= BASS_PATTERN.length) {
                    beatIndex = 0;
                    chordIndex = (chordIndex + 1) % CHORD_PROGRESSION.length;
                }

                scheduleTimeout(playBass, BEAT_TIME * 0.5 * 1000);
            }

            playBass();
        }

        function startDrumLayer(ctx, output) {
            let beat = 0;

            function playDrum() {
                if (!musicPlaying) return;

                const now = ctx.currentTime;

                if (beat % 4 === 0) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                    osc.connect(gain);
                    gain.connect(output);
                    gain.gain.setValueAtTime(0.4, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                }

                if (beat % 4 === 2) {
                    const noise = ctx.createBufferSource();
                    const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < buffer.length; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    noise.buffer = buffer;

                    const filter = ctx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = 3000;
                    filter.Q.value = 1;

                    const gain = ctx.createGain();
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(output);

                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                    noise.start(now);
                    noise.stop(now + 0.1);
                }

                const hihatVol = (beat % 2 === 0) ? 0.06 : 0.03;
                const noise = ctx.createBufferSource();
                const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.03, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < buffer.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;

                const filter = ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 8000;

                const gain = ctx.createGain();
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(output);

                gain.gain.setValueAtTime(hihatVol, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                noise.start(now);
                noise.stop(now + 0.05);

                beat++;
                scheduleTimeout(playDrum, BEAT_TIME * 0.5 * 1000);
            }

            playDrum();
        }

        function startArpLayer(ctx, dry, wet) {
            let chordIndex = 0;
            let arpIndex = 0;
            const arpPattern = [0, 1, 2, 1];

            function playArp() {
                if (!musicPlaying) return;

                const chord = CHORD_PROGRESSION[chordIndex];
                const noteIdx = arpPattern[arpIndex % arpPattern.length];
                const freq = chord.notes[noteIdx] * 4;

                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'sine';
                osc.frequency.value = freq;

                osc.connect(gain);
                gain.connect(dry);
                gain.connect(wet);

                const now = ctx.currentTime;
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + BEAT_TIME * 0.3);

                osc.start(now);
                osc.stop(now + BEAT_TIME * 0.4);

                arpIndex++;
                if (arpIndex >= 8) {
                    arpIndex = 0;
                    chordIndex = (chordIndex + 1) % CHORD_PROGRESSION.length;
                }

                scheduleTimeout(playArp, BEAT_TIME * 0.5 * 1000);
            }

            scheduleTimeout(playArp, BEAT_TIME * 2 * 1000);
        }

        function stopMusic() {
            musicPlaying = false;
            musicTimeouts.forEach(id => clearTimeout(id));
            musicTimeouts = [];
            if (musicNodes.master) {
                musicNodes.master.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
            }
            console.log('ðŸŽµ Music stopped');
        }

        function toggleMusic() {
            if (musicPlaying) {
                stopMusic();
            } else {
                startMusic();
            }
        }

        // ============================================
        // ASSET LOADING
        // ============================================

        const assets = {
            player: null,
            customer: null,
            shelfDrinks: null,
            shelfSnacks: null,
            shelfBento: null
        };

        let assetsLoaded = 0;
        const totalAssets = 5;

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    assetsLoaded++;
                    resolve(img);
                };
                img.onerror = () => {
                    console.warn(`Failed to load: ${src}, using fallback`);
                    assetsLoaded++;
                    resolve(null);
                };
                img.src = src;
            });
        }

        async function loadAssets() {
            const basePath = 'assets/';
            assets.player = await loadImage(basePath + 'player.jpeg');
            assets.customer = await loadImage(basePath + 'customer-1.jpeg');
            assets.shelfDrinks = await loadImage(basePath + 'shelf-drinks.jpeg');
            assets.shelfSnacks = await loadImage(basePath + 'shelf-snacks.jpeg');
            assets.shelfBento = await loadImage(basePath + 'shelf-bento.jpeg');
            console.log(`Assets loaded: ${assetsLoaded}/${totalAssets}`);
        }

        // ============================================
        // GAME STATE
        // ============================================

        const TILE_SIZE = 48;
        const GRID_W = 13;
        const GRID_H = 10;

        // Player
        const player = {
            x: 11,
            y: 5,
            holding: 0,
            maxHold: 6,
            color: '#ff6b6b'
        };

        // Register location (right side of store)
        const register = {
            x: 11,
            y: 4,
            color: '#8B4513'
        };

        // Shelves (start with some stock, but not full)
        const shelves = [
            { x: 2, y: 2, items: 8, maxItems: 10, type: 'drinks', color: '#4ecdc4', price: 2 },
            { x: 6, y: 2, items: 7, maxItems: 10, type: 'snacks', color: '#ffe66d', price: 3 },
            { x: 10, y: 2, items: 6, maxItems: 10, type: 'bento', color: '#ff8b94', price: 5 }
        ];

        // Stockroom area
        const stockroomY = 8;

        // Game stats
        let totalSales = 0;
        let customersServed = 0;

        // Sparkle effects
        const sparkles = [];

        // ============================================
        // CUSTOMER SYSTEM - Full Shopping Loop
        // ============================================

        const customers = [];
        let lastCustomerTime = Date.now();
        const CUSTOMER_INTERVAL = 6000; // New customer every 6 seconds
        const MAX_CUSTOMERS = 3;

        const CUSTOMER_COLORS = ['#e8b4b8', '#b4d4e8', '#d4e8b4', '#e8d4b4'];

        // Customer states:
        // 'entering' - walking into store
        // 'shopping' - walking to a shelf
        // 'grabbing' - taking items from shelf
        // 'to_register' - walking to register
        // 'waiting' - waiting at register for checkout
        // 'leaving' - exiting store

        function spawnCustomer() {
            // Decide how many items they want to buy (1-3)
            const itemsToBuy = 1 + Math.floor(Math.random() * 3);

            // Create shopping list (which shelf types to visit)
            const shelfTypes = ['drinks', 'snacks', 'bento'];
            const shoppingList = [];
            for (let i = 0; i < itemsToBuy; i++) {
                const type = shelfTypes[Math.floor(Math.random() * shelfTypes.length)];
                shoppingList.push(type);
            }

            const customer = {
                x: 6,
                y: 0,
                targetX: 6,
                targetY: 1,
                color: CUSTOMER_COLORS[Math.floor(Math.random() * CUSTOMER_COLORS.length)],
                state: 'entering',
                shoppingList: shoppingList, // What they want to buy
                cart: [], // Items they've grabbed
                currentShopIndex: 0, // Which item in shopping list they're getting
                moveTimer: 0,
                grabTimer: 0,
                waitTime: 0
            };
            customers.push(customer);
            playDoorSound();
        }

        function playDoorSound() {
            setTimeout(() => playTone(659, 0.15, 'sine'), 0);
            setTimeout(() => playTone(523, 0.2, 'sine'), 150);
        }

        function getShelfByType(type) {
            return shelves.find(s => s.type === type);
        }

        function updateCustomers() {
            const now = Date.now();

            // Spawn new customers
            if (now - lastCustomerTime > CUSTOMER_INTERVAL && customers.length < MAX_CUSTOMERS) {
                spawnCustomer();
                lastCustomerTime = now;
            }

            customers.forEach((c, index) => {
                // Movement timing
                if (now - c.moveTimer < 350) return;
                c.moveTimer = now;

                switch (c.state) {
                    case 'entering':
                        // Move into the store
                        if (c.y < 3) {
                            c.y++;
                        } else {
                            c.state = 'shopping';
                            setNextShoppingTarget(c);
                        }
                        break;

                    case 'shopping':
                        // Move toward target shelf
                        if (moveToward(c, c.targetX, c.targetY)) {
                            // Arrived at shelf
                            c.state = 'grabbing';
                            c.grabTimer = now;
                        }
                        break;

                    case 'grabbing':
                        // Take a moment to grab item
                        if (now - c.grabTimer > 800) {
                            const wantType = c.shoppingList[c.currentShopIndex];
                            const shelf = getShelfByType(wantType);

                            if (shelf && shelf.items > 0) {
                                // Take item from shelf
                                shelf.items--;
                                c.cart.push({ type: wantType, price: shelf.price });
                                playGrab();
                            }

                            c.currentShopIndex++;

                            // More items to get?
                            if (c.currentShopIndex < c.shoppingList.length) {
                                c.state = 'shopping';
                                setNextShoppingTarget(c);
                            } else {
                                // Done shopping, head to register
                                c.state = 'to_register';
                                c.targetX = register.x - 1;
                                c.targetY = register.y;
                            }
                        }
                        break;

                    case 'to_register':
                        // Walk to register
                        if (moveToward(c, c.targetX, c.targetY)) {
                            c.state = 'waiting';
                            c.waitTime = now;
                        }
                        break;

                    case 'waiting':
                        // Wait for player to check them out
                        // (Player interaction handles state change)
                        break;

                    case 'leaving':
                        // Exit the store
                        if (c.y > 0) {
                            c.y--;
                        } else if (c.x !== 6) {
                            c.x += c.x < 6 ? 1 : -1;
                        } else {
                            // Remove customer
                            customers.splice(index, 1);
                        }
                        break;
                }
            });
        }

        function setNextShoppingTarget(customer) {
            const wantType = customer.shoppingList[customer.currentShopIndex];
            const shelf = getShelfByType(wantType);
            if (shelf) {
                // Stand in front of shelf (below it)
                customer.targetX = shelf.x;
                customer.targetY = shelf.y + 1;
            }
        }

        function moveToward(entity, targetX, targetY) {
            if (entity.x < targetX) entity.x++;
            else if (entity.x > targetX) entity.x--;
            else if (entity.y < targetY) entity.y++;
            else if (entity.y > targetY) entity.y--;
            else return true; // Arrived
            return false;
        }

        function checkoutCustomer() {
            // Find customer waiting at register
            const waitingCustomer = customers.find(c =>
                c.state === 'waiting' &&
                Math.abs(c.x - player.x) <= 1 &&
                Math.abs(c.y - player.y) <= 1
            );

            if (waitingCustomer && waitingCustomer.cart.length > 0) {
                // Calculate total
                const total = waitingCustomer.cart.reduce((sum, item) => sum + item.price, 0);
                totalSales += total;
                customersServed++;

                // Play cash register sound
                playCashRegister();

                // Happy sparkles
                for (let i = 0; i < 8; i++) {
                    sparkles.push({
                        x: (waitingCustomer.x + 0.5) * TILE_SIZE,
                        y: (waitingCustomer.y + 0.5) * TILE_SIZE,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        life: 1,
                        color: '#ffd93d'
                    });
                }

                // Customer leaves happy
                waitingCustomer.state = 'leaving';
                return true;
            }
            return false;
        }

        // ============================================
        // INPUT HANDLING
        // ============================================

        const keys = {};
        const ACTION_DELAY = 150;
        const MOVE_DELAY = 165;

        const keyPressTime = {};

        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyM') {
                e.preventDefault();
                toggleMusic();
                updateMusicButton();
                return;
            }

            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyE', 'Space'].includes(e.code)) {
                e.preventDefault();
                initAudio();

                if (!keys[e.code]) {
                    keys[e.code] = true;
                    keyPressTime[e.code] = Date.now();
                }
            }
        });

        function updateMusicButton() {
            const btn = document.getElementById('musicBtn');
            if (musicPlaying) {
                btn.textContent = 'ðŸ”‡ Stop Music (M)';
                btn.style.background = '#6b4a4a';
            } else {
                btn.textContent = 'ðŸŽµ Play Music (M)';
                btn.style.background = '#4a4a6a';
            }
        }

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            keyPressTime[e.code] = 0;
        });

        // ============================================
        // GAMEPAD (PS5 CONTROLLER) SUPPORT
        // ============================================

        const gamepadState = {
            up: false,
            down: false,
            left: false,
            right: false,
            action: false,      // X button (Cross) - checkout/stock
            pickup: false,      // Square button - pickup from stockroom
            music: false        // Options button - toggle music
        };

        const STICK_DEADZONE = 0.3;
        let lastMusicToggle = 0;
        let controllerConnected = false;
        const controllerStatusEl = document.getElementById('controllerStatus');

        // Controller connection events
        window.addEventListener('gamepadconnected', (e) => {
            controllerConnected = true;
            controllerStatusEl.textContent = `ðŸŽ® Controller connected: ${e.gamepad.id}`;
            controllerStatusEl.style.color = '#6bcb77';
            initAudio();
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            controllerConnected = false;
            controllerStatusEl.textContent = 'ðŸŽ® Controller disconnected';
            controllerStatusEl.style.color = '#666';
        });

        function pollGamepad() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];

            for (const gp of gamepads) {
                if (!gp) continue;

                // PS5 DualSense mapping (standard gamepad):
                // Buttons: 0=Cross(X), 1=Circle, 2=Square, 3=Triangle
                //          9=Options, 12=DpadUp, 13=DpadDown, 14=DpadLeft, 15=DpadRight
                // Axes: 0=LeftStickX, 1=LeftStickY

                const leftStickX = gp.axes[0] || 0;
                const leftStickY = gp.axes[1] || 0;

                // D-pad or left stick for movement
                gamepadState.up = gp.buttons[12]?.pressed || leftStickY < -STICK_DEADZONE;
                gamepadState.down = gp.buttons[13]?.pressed || leftStickY > STICK_DEADZONE;
                gamepadState.left = gp.buttons[14]?.pressed || leftStickX < -STICK_DEADZONE;
                gamepadState.right = gp.buttons[15]?.pressed || leftStickX > STICK_DEADZONE;

                // Action buttons
                gamepadState.action = gp.buttons[0]?.pressed;  // Cross (X) - interact
                gamepadState.pickup = gp.buttons[2]?.pressed;  // Square - pickup

                // Music toggle (Options button) with debounce
                const optionsPressed = gp.buttons[9]?.pressed;
                const now = Date.now();
                if (optionsPressed && now - lastMusicToggle > 500) {
                    toggleMusic();
                    updateMusicButton();
                    lastMusicToggle = now;
                }

                // Initialize audio on any button press
                if (gamepadState.action || gamepadState.pickup) {
                    initAudio();
                }

                break; // Use first connected gamepad
            }
        }

        let lastActionTime = 0;
        let lastMoveTime = 0;

        function gameLoop() {
            const now = Date.now();

            // Poll gamepad state
            pollGamepad();

            updateCustomers();

            // Movement (keyboard or gamepad)
            if (now - lastMoveTime >= MOVE_DELAY) {
                if (keys['ArrowUp'] || gamepadState.up) { handleMovement('ArrowUp'); lastMoveTime = now; }
                else if (keys['ArrowDown'] || gamepadState.down) { handleMovement('ArrowDown'); lastMoveTime = now; }
                else if (keys['ArrowLeft'] || gamepadState.left) { handleMovement('ArrowLeft'); lastMoveTime = now; }
                else if (keys['ArrowRight'] || gamepadState.right) { handleMovement('ArrowRight'); lastMoveTime = now; }
            }

            // Actions (keyboard or gamepad)
            if (now - lastActionTime >= ACTION_DELAY) {
                if (keys['KeyE'] || gamepadState.action) { handleAction('KeyE'); lastActionTime = now; }
                else if (keys['Space'] || gamepadState.pickup) { handleAction('Space'); lastActionTime = now; }
            }

            requestAnimationFrame(gameLoop);
        }
        gameLoop();

        function handleMovement(code) {
            let newX = player.x;
            let newY = player.y;

            switch(code) {
                case 'ArrowUp': newY--; break;
                case 'ArrowDown': newY++; break;
                case 'ArrowLeft': newX--; break;
                case 'ArrowRight': newX++; break;
            }

            if (newX >= 0 && newX < GRID_W && newY >= 0 && newY < GRID_H) {
                // Don't walk through shelves or register
                const blockedByShelf = shelves.some(s => s.x === newX && s.y === newY);
                const blockedByRegister = (newX === register.x && newY === register.y);
                if (!blockedByShelf && !blockedByRegister) {
                    player.x = newX;
                    player.y = newY;
                }
            }

            updateStatus();
        }

        function handleAction(code) {
            switch(code) {
                case 'KeyE': interact(); break;
                case 'Space': pickupFromStockroom(); break;
            }
        }

        function interact() {
            // Priority 1: Checkout customer at register
            if (checkoutCustomer()) {
                updateStatus();
                return;
            }

            // Priority 2: Stock a shelf if holding items
            const adjacentShelf = shelves.find(s =>
                Math.abs(s.x - player.x) + Math.abs(s.y - player.y) === 1
            );

            if (adjacentShelf && player.holding > 0) {
                if (adjacentShelf.items < adjacentShelf.maxItems) {
                    adjacentShelf.items++;
                    player.holding--;
                    playShelfTone(adjacentShelf.items);

                    // Sparkle if fully stocked
                    if (adjacentShelf.items >= adjacentShelf.maxItems) {
                        playComplete();
                        for (let i = 0; i < 10; i++) {
                            sparkles.push({
                                x: (adjacentShelf.x + 0.5) * TILE_SIZE,
                                y: (adjacentShelf.y + 0.5) * TILE_SIZE,
                                vx: (Math.random() - 0.5) * 6,
                                vy: (Math.random() - 0.5) * 6,
                                life: 1,
                                color: adjacentShelf.color
                            });
                        }
                    }
                }
            }
            updateStatus();
        }

        function playReturn() {
            playTone(280, 0.08, 'triangle');
        }

        function pickupFromStockroom() {
            if (player.y >= stockroomY && player.holding < player.maxHold) {
                player.holding++;
                playPickup();
            }
            updateStatus();
        }

        function updateStatus() {
            const waiting = customers.filter(c => c.state === 'waiting').length;
            const lowStock = shelves.filter(s => s.items <= 3).length;

            let status = `ðŸ’° Sales: $${totalSales} | ðŸ‘¥ Served: ${customersServed}`;

            if (waiting > 0) {
                status += ` | â³ Waiting: ${waiting}`;
            }
            if (lowStock > 0) {
                status += ` | âš ï¸ Low stock: ${lowStock}`;
            }
            if (player.holding > 0) {
                status += ` | ðŸ“¦ Carrying: ${player.holding}`;
            }

            statusEl.textContent = status;
        }

        // ============================================
        // RENDERING
        // ============================================

        function draw() {
            // Background
            ctx.fillStyle = '#f5e6d3';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Floor tiles
            for (let y = 0; y < GRID_H; y++) {
                for (let x = 0; x < GRID_W; x++) {
                    ctx.fillStyle = (x + y) % 2 === 0 ? '#efe0cc' : '#f5e6d3';
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // Grid lines
            ctx.strokeStyle = '#d4c4b0';
            ctx.lineWidth = 1;
            for (let x = 0; x <= GRID_W; x++) {
                ctx.beginPath();
                ctx.moveTo(x * TILE_SIZE, 0);
                ctx.lineTo(x * TILE_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= GRID_H; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * TILE_SIZE);
                ctx.lineTo(canvas.width, y * TILE_SIZE);
                ctx.stroke();
            }

            // Door
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(5 * TILE_SIZE, 0, 3 * TILE_SIZE, TILE_SIZE - 4);
            ctx.fillStyle = '#4a90a4';
            ctx.fillRect(5 * TILE_SIZE, 0, 3 * TILE_SIZE, 8);
            ctx.fillStyle = '#2c5f6e';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('ðŸšª ENTRANCE', 6.5 * TILE_SIZE, TILE_SIZE/2 + 8);
            ctx.textAlign = 'left';

            // Stockroom
            ctx.fillStyle = '#c4b8a8';
            ctx.fillRect(0, stockroomY * TILE_SIZE, canvas.width, (GRID_H - stockroomY) * TILE_SIZE);
            ctx.fillStyle = '#a08060';
            ctx.fillRect(10, stockroomY * TILE_SIZE + 10, 80, 60);
            ctx.fillRect(canvas.width - 90, stockroomY * TILE_SIZE + 10, 80, 60);
            ctx.fillStyle = '#8b7355';
            ctx.font = '13px sans-serif';
            ctx.fillText('ðŸ“¦ STOCKROOM - Hold SPACE to grab items', 180, stockroomY * TILE_SIZE + 45);

            // Register
            const regX = register.x * TILE_SIZE;
            const regY = register.y * TILE_SIZE;
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(regX + 4, regY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
            ctx.fillStyle = '#D2691E';
            ctx.fillRect(regX + 8, regY + 8, TILE_SIZE - 16, TILE_SIZE - 20);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('ðŸ’µ', regX + TILE_SIZE/2, regY + TILE_SIZE/2 + 4);
            ctx.font = '9px sans-serif';
            ctx.fillText('REGISTER', regX + TILE_SIZE/2, regY + TILE_SIZE - 4);
            ctx.textAlign = 'left';

            // Shelves
            shelves.forEach(shelf => {
                const shelfX = shelf.x * TILE_SIZE;
                const shelfY = shelf.y * TILE_SIZE;
                const fillRatio = shelf.items / shelf.maxItems;

                let shelfImg = null;
                if (shelf.type === 'drinks') shelfImg = assets.shelfDrinks;
                else if (shelf.type === 'snacks') shelfImg = assets.shelfSnacks;
                else if (shelf.type === 'bento') shelfImg = assets.shelfBento;

                if (shelfImg) {
                    const size = TILE_SIZE * 2;
                    ctx.globalAlpha = 0.3 + (fillRatio * 0.7);

                    // Warning glow if low stock
                    if (shelf.items <= 3) {
                        ctx.shadowColor = '#ff4444';
                        ctx.shadowBlur = 10 + Math.sin(Date.now() / 200) * 5;
                    }

                    ctx.drawImage(shelfImg, shelfX - TILE_SIZE/2, shelfY - TILE_SIZE/2, size, size);
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                } else {
                    const brightness = 0.3 + (fillRatio * 0.7);
                    ctx.fillStyle = adjustBrightness(shelf.color, brightness);
                    ctx.fillRect(shelfX + 4, shelfY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                }

                // Stock count with warning color if low
                const isLow = shelf.items <= 3;
                ctx.fillStyle = isLow ? '#ff4444' : '#000';
                ctx.fillRect(shelfX + TILE_SIZE/2 - 18, shelfY + TILE_SIZE - 16, 36, 16);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(
                    `${shelf.items}/${shelf.maxItems}`,
                    shelfX + TILE_SIZE/2,
                    shelfY + TILE_SIZE - 4
                );

                // Price label
                ctx.fillStyle = '#2a2';
                ctx.font = '10px sans-serif';
                ctx.fillText(`$${shelf.price}`, shelfX + TILE_SIZE/2, shelfY - 4);
            });

            ctx.textAlign = 'left';

            // Player
            const px = player.x * TILE_SIZE;
            const py = player.y * TILE_SIZE;

            if (assets.player) {
                ctx.drawImage(assets.player, px, py - 8, TILE_SIZE, TILE_SIZE + 8);
            } else {
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, TILE_SIZE/3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Held items
            if (player.holding > 0) {
                const centerX = px + TILE_SIZE/2;

                for (let i = 0; i < player.holding; i++) {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(centerX - 8, py - 12 - (i * 6), 16, 5);
                    ctx.strokeStyle = '#5D3A1A';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(centerX - 8, py - 12 - (i * 6), 16, 5);
                }

                ctx.fillStyle = '#ffd93d';
                ctx.beginPath();
                ctx.arc(centerX + 12, py - 8, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(player.holding.toString(), centerX + 12, py - 4);
                ctx.textAlign = 'left';
            }

            // Customers
            customers.forEach(customer => {
                const custX = customer.x * TILE_SIZE;
                const custY = customer.y * TILE_SIZE;
                const cx = custX + TILE_SIZE/2;
                const cy = custY + TILE_SIZE/2;

                if (assets.customer) {
                    const imgW = assets.customer.width / 3;
                    const imgH = assets.customer.height;
                    ctx.drawImage(
                        assets.customer,
                        imgW, 0, imgW, imgH,
                        custX, custY - 8, TILE_SIZE, TILE_SIZE + 8
                    );
                } else {
                    ctx.fillStyle = customer.color;
                    ctx.beginPath();
                    ctx.arc(cx, cy, TILE_SIZE/4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Shopping basket with item count
                if (customer.cart.length > 0 || customer.state === 'shopping' || customer.state === 'grabbing') {
                    // Basket icon
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(cx - 12, cy + 12, 24, 14);
                    ctx.strokeStyle = '#5D3A1A';
                    ctx.strokeRect(cx - 12, cy + 12, 24, 14);

                    // Item count in basket
                    if (customer.cart.length > 0) {
                        ctx.fillStyle = '#ffd93d';
                        ctx.beginPath();
                        ctx.arc(cx + 8, cy + 10, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 9px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(customer.cart.length.toString(), cx + 8, cy + 13);
                    }
                }

                // Thought bubble showing what they want (while shopping)
                if (customer.state === 'shopping' || customer.state === 'grabbing') {
                    const wantType = customer.shoppingList[customer.currentShopIndex];

                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.ellipse(cx + 20, cy - 30, 18, 12, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(cx + 8, cy - 18);
                    ctx.lineTo(cx + 14, cy - 24);
                    ctx.lineTo(cx + 18, cy - 18);
                    ctx.fill();

                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    let emoji = 'â“';
                    if (wantType === 'drinks') emoji = 'ðŸ¥¤';
                    else if (wantType === 'snacks') emoji = 'ðŸª';
                    else if (wantType === 'bento') emoji = 'ðŸ±';
                    ctx.fillText(emoji, cx + 20, cy - 27);
                    ctx.textAlign = 'left';
                }

                // Waiting indicator at register
                if (customer.state === 'waiting') {
                    const waitDuration = (Date.now() - customer.waitTime) / 1000;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.ellipse(cx + 20, cy - 30, 18, 12, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = waitDuration > 5 ? '#ff4444' : '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(waitDuration > 5 ? 'ðŸ˜¤' : 'ðŸ’µ', cx + 20, cy - 27);
                    ctx.textAlign = 'left';
                }

                // Happy face when leaving after checkout
                if (customer.state === 'leaving') {
                    ctx.font = '18px sans-serif';
                    ctx.fillText('ðŸ˜Š', cx - 8, cy - 25);
                }
            });

            // Sparkles
            sparkles.forEach((s, i) => {
                ctx.fillStyle = s.color;
                ctx.globalAlpha = s.life;
                ctx.beginPath();
                ctx.arc(s.x, s.y, 4 * s.life, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                s.x += s.vx;
                s.y += s.vy;
                s.life -= 0.02;
            });

            for (let i = sparkles.length - 1; i >= 0; i--) {
                if (sparkles[i].life <= 0) sparkles.splice(i, 1);
            }

            requestAnimationFrame(draw);
        }

        function adjustBrightness(hex, factor) {
            const r = parseInt(hex.slice(1,3), 16);
            const g = parseInt(hex.slice(3,5), 16);
            const b = parseInt(hex.slice(5,7), 16);

            const newR = Math.min(255, Math.floor(r * factor));
            const newG = Math.min(255, Math.floor(g * factor));
            const newB = Math.min(255, Math.floor(b * factor));

            return `rgb(${newR}, ${newG}, ${newB})`;
        }

        // Start
        async function init() {
            console.log('Loading assets...');
            await loadAssets();
            console.log('Dunkin Konbini Simulator v8.0 loaded! Full shopping loop active.');
            draw();
            updateStatus();
        }
        init();
    </script>
</body>
</html>
