<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Ç≥„É≥„Éì„Éã Master - Konbini Simulator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a472a 0%, #0d2818 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            color: #eee;
        }
        h1 {
            margin-bottom: 10px;
            color: #ff6b35;
            text-shadow: 2px 2px 0 #fff, 3px 3px 0 #1a472a;
            font-size: 28px;
        }
        .instructions {
            margin-bottom: 15px;
            color: #ccc;
            font-size: 14px;
            background: rgba(0,0,0,0.3);
            padding: 8px 16px;
            border-radius: 20px;
        }
        canvas {
            border: 4px solid #fff;
            border-radius: 4px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }
        .status {
            margin-top: 15px;
            font-size: 20px;
            color: #fff;
            background: linear-gradient(90deg, #ee3124 0%, #ff6b35 100%);
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0 4px 0 #b31f16;
        }
        .hint {
            margin-top: 10px;
            color: #8a8;
            font-size: 12px;
        }
        #musicBtn {
            margin-top: 15px;
            padding: 10px 20px;
            background: #1a472a;
            color: #fff;
            border: 2px solid #ff6b35;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        #musicBtn:hover {
            background: #2a573a;
        }
    </style>
</head>
<body>
    <h1>üè™ „Ç≥„É≥„Éì„Éã Master</h1>
    <div class="instructions">Arrow Keys / Left Stick = Move | E / X = Checkout / Stock | Space / Square = Load | M / Options = Music</div>
    <div id="controllerStatus" style="margin-top: 5px; color: #8a8; font-size: 11px; height: 14px;"></div>
    <canvas id="game" width="672" height="528"></canvas>
    <div class="status" id="status">üí¥ ¬•0 | „ÅÑ„Çâ„Å£„Åó„ÇÉ„ÅÑ„Åæ„Åõ!</div>
    <div class="hint">Customers shop the shelves, then head to the register. Check them out with E!</div>
    <button id="musicBtn" onclick="toggleMusic(); updateMusicButton();">üéµ Play Music (M)</button>

    <script>
        // ============================================
        // „Ç≥„É≥„Éì„Éã MASTER v9.0
        // Authentic Japanese Konbini Layout
        // ============================================

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        // Audio
        let audioCtx = null;
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playTone(freq, duration = 0.1, type = 'square') {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.value = 0.15;
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function playShelfTone(count) {
            playTone(220 + (count * 50), 0.12, 'square');
        }

        function playComplete() {
            setTimeout(() => playTone(523, 0.1, 'sine'), 0);
            setTimeout(() => playTone(659, 0.1, 'sine'), 80);
            setTimeout(() => playTone(784, 0.15, 'sine'), 160);
            setTimeout(() => playTone(1047, 0.3, 'sine'), 240);
        }

        function playPickup() {
            playTone(330, 0.08, 'triangle');
        }

        function playCashRegister() {
            setTimeout(() => playTone(800, 0.05, 'square'), 0);
            setTimeout(() => playTone(1000, 0.05, 'square'), 50);
            setTimeout(() => playTone(1200, 0.1, 'sine'), 100);
            setTimeout(() => playTone(1600, 0.15, 'sine'), 150);
        }

        function playGrab() {
            playTone(440, 0.06, 'triangle');
        }

        function playDoorChime() {
            // Classic konbini door chime
            setTimeout(() => playTone(880, 0.15, 'sine'), 0);
            setTimeout(() => playTone(660, 0.15, 'sine'), 150);
            setTimeout(() => playTone(880, 0.2, 'sine'), 300);
        }

        // ============================================
        // MUSIC SYSTEM
        // ============================================

        let musicPlaying = false;
        let musicNodes = {};
        let musicTimeouts = [];

        const BPM = 128;
        const BEAT_TIME = 60 / BPM;

        const NOTES = {
            C3: 130.81, D3: 146.83, E3: 164.81, G3: 196.00, A3: 220.00,
            C4: 261.63, D4: 293.66, E4: 329.63, G4: 392.00, A4: 440.00,
            C5: 523.25, D5: 587.33, E5: 659.25, G5: 783.99, A5: 880.00,
        };

        const CHORD_PROGRESSION = [
            { root: 'C', notes: [NOTES.C3, NOTES.E3, NOTES.G3] },
            { root: 'G', notes: [NOTES.G3, NOTES.D4, NOTES.G4] },
            { root: 'A', notes: [NOTES.A3, NOTES.C4, NOTES.E4] },
            { root: 'F', notes: [NOTES.G3, NOTES.C4, NOTES.E4] },
        ];

        const HAPPY_MELODIES = [
            ['C5', 'E5', 'G5', 'E5', 'C5', 'D5', 'E5', 'G5'],
            ['G5', 'E5', 'D5', 'C5', 'D5', 'E5', 'G5', 'A5'],
            ['E5', 'G5', 'A5', 'G5', 'E5', 'D5', 'C5', 'E5'],
            ['C5', 'C5', 'G4', 'G4', 'A4', 'A4', 'G4', null],
        ];

        const BASS_PATTERN = [1, 0, 1, 0, 1, 1, 0, 1];

        function createMusicContext() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            return audioCtx;
        }

        function scheduleTimeout(fn, time) {
            const id = setTimeout(fn, time);
            musicTimeouts.push(id);
            return id;
        }

        function startMusic() {
            if (musicPlaying) return;
            const ctx = createMusicContext();
            musicPlaying = true;
            musicTimeouts = [];

            const masterGain = ctx.createGain();
            masterGain.gain.value = 0.35;
            masterGain.connect(ctx.destination);
            musicNodes.master = masterGain;

            const convolver = ctx.createConvolver();
            const length = ctx.sampleRate * 0.5;
            const impulse = ctx.createBuffer(2, length, ctx.sampleRate);
            for (let ch = 0; ch < 2; ch++) {
                const data = impulse.getChannelData(ch);
                for (let i = 0; i < length; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3);
                }
            }
            convolver.buffer = impulse;

            const dryGain = ctx.createGain();
            const wetGain = ctx.createGain();
            dryGain.gain.value = 0.85;
            wetGain.gain.value = 0.15;
            dryGain.connect(masterGain);
            convolver.connect(wetGain);
            wetGain.connect(masterGain);

            musicNodes.dry = dryGain;
            musicNodes.wet = convolver;

            startChordLayer(ctx, dryGain);
            startMelodyLayer(ctx, dryGain, convolver);
            startBassLayer(ctx, dryGain);
            startDrumLayer(ctx, dryGain);
            startArpLayer(ctx, dryGain, convolver);
        }

        function startChordLayer(ctx, output) {
            let idx = 0;
            function play() {
                if (!musicPlaying) return;
                CHORD_PROGRESSION[idx].notes.forEach(freq => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = freq * 2;
                    osc.connect(gain);
                    gain.connect(output);
                    const now = ctx.currentTime;
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.08, now + 0.02);
                    gain.gain.linearRampToValueAtTime(0, now + BEAT_TIME * 4 - 0.05);
                    osc.start(now);
                    osc.stop(now + BEAT_TIME * 4);
                });
                idx = (idx + 1) % CHORD_PROGRESSION.length;
                scheduleTimeout(play, BEAT_TIME * 4 * 1000);
            }
            play();
        }

        function startMelodyLayer(ctx, dry, wet) {
            let pIdx = 0, nIdx = 0;
            function play() {
                if (!musicPlaying) return;
                const note = HAPPY_MELODIES[pIdx][nIdx];
                if (note && NOTES[note]) {
                    const freq = NOTES[note];
                    const osc = ctx.createOscillator();
                    const osc2 = ctx.createOscillator();
                    const gain = ctx.createGain();
                    const filter = ctx.createBiquadFilter();
                    osc.type = 'square'; osc.frequency.value = freq;
                    osc2.type = 'sine'; osc2.frequency.value = freq;
                    filter.type = 'lowpass'; filter.frequency.value = 3000;
                    const g1 = ctx.createGain(); g1.gain.value = 0.3;
                    const g2 = ctx.createGain(); g2.gain.value = 0.7;
                    osc.connect(g1); osc2.connect(g2);
                    g1.connect(filter); g2.connect(filter);
                    filter.connect(gain);
                    gain.connect(dry); gain.connect(wet);
                    const now = ctx.currentTime;
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + BEAT_TIME * 0.8);
                    osc.start(now); osc2.start(now);
                    osc.stop(now + BEAT_TIME); osc2.stop(now + BEAT_TIME);
                }
                nIdx++;
                if (nIdx >= HAPPY_MELODIES[pIdx].length) { nIdx = 0; pIdx = (pIdx + 1) % HAPPY_MELODIES.length; }
                scheduleTimeout(play, BEAT_TIME * 0.5 * 1000);
            }
            scheduleTimeout(play, BEAT_TIME * 4 * 1000);
        }

        function startBassLayer(ctx, output) {
            let cIdx = 0, bIdx = 0;
            function play() {
                if (!musicPlaying) return;
                if (BASS_PATTERN[bIdx]) {
                    const freq = CHORD_PROGRESSION[cIdx].notes[0];
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    const filter = ctx.createBiquadFilter();
                    osc.type = 'sine'; osc.frequency.value = freq;
                    filter.type = 'lowpass'; filter.frequency.value = 500;
                    osc.connect(filter); filter.connect(gain); gain.connect(output);
                    const now = ctx.currentTime;
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + BEAT_TIME * 0.4);
                    osc.start(now); osc.stop(now + BEAT_TIME * 0.5);
                }
                bIdx++;
                if (bIdx >= BASS_PATTERN.length) { bIdx = 0; cIdx = (cIdx + 1) % CHORD_PROGRESSION.length; }
                scheduleTimeout(play, BEAT_TIME * 0.5 * 1000);
            }
            play();
        }

        function startDrumLayer(ctx, output) {
            let beat = 0;
            function play() {
                if (!musicPlaying) return;
                const now = ctx.currentTime;
                if (beat % 4 === 0) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                    osc.connect(gain); gain.connect(output);
                    gain.gain.setValueAtTime(0.4, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now); osc.stop(now + 0.15);
                }
                if (beat % 4 === 2) {
                    const noise = ctx.createBufferSource();
                    const buf = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
                    const data = buf.getChannelData(0);
                    for (let i = 0; i < buf.length; i++) data[i] = Math.random() * 2 - 1;
                    noise.buffer = buf;
                    const filter = ctx.createBiquadFilter();
                    filter.type = 'bandpass'; filter.frequency.value = 3000;
                    const gain = ctx.createGain();
                    noise.connect(filter); filter.connect(gain); gain.connect(output);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                    noise.start(now); noise.stop(now + 0.1);
                }
                const hihatVol = (beat % 2 === 0) ? 0.06 : 0.03;
                const noise = ctx.createBufferSource();
                const buf = ctx.createBuffer(1, ctx.sampleRate * 0.03, ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < buf.length; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buf;
                const filter = ctx.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 8000;
                const gain = ctx.createGain();
                noise.connect(filter); filter.connect(gain); gain.connect(output);
                gain.gain.setValueAtTime(hihatVol, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                noise.start(now); noise.stop(now + 0.05);
                beat++;
                scheduleTimeout(play, BEAT_TIME * 0.5 * 1000);
            }
            play();
        }

        function startArpLayer(ctx, dry, wet) {
            let cIdx = 0, aIdx = 0;
            const pattern = [0, 1, 2, 1];
            function play() {
                if (!musicPlaying) return;
                const freq = CHORD_PROGRESSION[cIdx].notes[pattern[aIdx % pattern.length]] * 4;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine'; osc.frequency.value = freq;
                osc.connect(gain); gain.connect(dry); gain.connect(wet);
                const now = ctx.currentTime;
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + BEAT_TIME * 0.3);
                osc.start(now); osc.stop(now + BEAT_TIME * 0.4);
                aIdx++;
                if (aIdx >= 8) { aIdx = 0; cIdx = (cIdx + 1) % CHORD_PROGRESSION.length; }
                scheduleTimeout(play, BEAT_TIME * 0.5 * 1000);
            }
            scheduleTimeout(play, BEAT_TIME * 2 * 1000);
        }

        function stopMusic() {
            musicPlaying = false;
            musicTimeouts.forEach(id => clearTimeout(id));
            musicTimeouts = [];
            if (musicNodes.master) {
                musicNodes.master.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
            }
        }

        function toggleMusic() {
            musicPlaying ? stopMusic() : startMusic();
        }

        function updateMusicButton() {
            const btn = document.getElementById('musicBtn');
            btn.textContent = musicPlaying ? 'üîá Stop Music (M)' : 'üéµ Play Music (M)';
        }

        // ============================================
        // ASSET LOADING
        // ============================================

        const assets = {
            player: null,
            customer: null,
            shelfDrinks: null,
            shelfSnacks: null,
            shelfBento: null,
            shelfOnigiri: null,
            shelfHot: null,
            shelfCoffee: null,
            shelfBread: null,
            shelfNoodles: null,
            shelfFrozen: null
        };

        function loadImage(src) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => { console.warn(`Failed: ${src}`); resolve(null); };
                img.src = src;
            });
        }

        async function loadAssets() {
            const bp = 'assets/';
            assets.player = await loadImage(bp + 'player.jpeg');
            assets.customer = await loadImage(bp + 'customer-1.jpeg');
            assets.shelfDrinks = await loadImage(bp + 'shelf-drinks.jpeg');
            assets.shelfSnacks = await loadImage(bp + 'shelf-snacks.jpeg');
            assets.shelfBento = await loadImage(bp + 'shelf-bento.jpeg');
            assets.shelfOnigiri = await loadImage(bp + 'shelf-onigiri.jpeg');
            assets.shelfHot = await loadImage(bp + 'shelf-hot.jpeg');
            assets.shelfCoffee = await loadImage(bp + 'shelf-coffee.jpeg');
            assets.shelfBread = await loadImage(bp + 'shelf-bread.jpeg');
            assets.shelfNoodles = await loadImage(bp + 'shelf-noodles.jpeg');
            assets.shelfFrozen = await loadImage(bp + 'shelf-frozen.jpeg');
        }

        // ============================================
        // GAME STATE - AUTHENTIC KONBINI LAYOUT
        // ============================================

        const TILE_SIZE = 48;
        const GRID_W = 14;
        const GRID_H = 11;

        // Entrance at BOTTOM center
        const entranceX = 6;
        const entranceY = GRID_H - 1; // Y = 10

        // Stockroom in back-left corner
        const stockroomArea = { x1: 0, y1: 0, x2: 1, y2: 1 };

        // Player starts near register
        const player = {
            x: 12,
            y: 6,
            holding: 0,
            maxHold: 6
        };

        // Register on right side, near entrance
        const register = { x: 12, y: 8 };

        // Hot food display next to register
        const hotFoodCounter = { x: 12, y: 7 };

        /*
         * AUTHENTIC KONBINI LAYOUT:
         *
         *   Y=0: [STOCK] [--BACK WALL REFRIGERATORS: ONIGIRI, BENTO, DAIRY--] [DRINKS]
         *   Y=1: [STOCK]                                                      [DRINKS]
         *   Y=2:         [====== GONDOLA: BREAD/PASTRIES ======]              [DRINKS]
         *   Y=3:
         *   Y=4:         [====== GONDOLA: SNACKS/CANDY ========]              [COFFEE]
         *   Y=5:
         *   Y=6:         [====== GONDOLA: NOODLES/HOUSEHOLD ===]
         *   Y=7: [FROZEN]                                                     [HOT FOOD]
         *   Y=8: [FROZEN] [---- MAGAZINES ----]                               [REGISTER]
         *   Y=9:
         *   Y=10:                    [=== ENTRANCE ===]
         */

        const shelves = [
            // Back wall refrigerators (Y=0)
            { x: 2, y: 0, items: 8, maxItems: 10, type: 'onigiri', color: '#fff5e6', price: 150, label: '„Åä„Å´„Åé„Çä' },
            { x: 4, y: 0, items: 7, maxItems: 10, type: 'bento', color: '#ffe4e1', price: 500, label: 'ÂºÅÂΩì' },
            { x: 6, y: 0, items: 6, maxItems: 10, type: 'bento', color: '#ffe4e1', price: 450, label: 'ÂºÅÂΩì' },
            { x: 8, y: 0, items: 8, maxItems: 10, type: 'onigiri', color: '#fff5e6', price: 130, label: '„Åä„Å´„Åé„Çä' },

            // Right wall drink coolers (vertical, X=13)
            { x: 13, y: 0, items: 9, maxItems: 10, type: 'drinks', color: '#e0f7fa', price: 150, label: 'È£≤Êñô' },
            { x: 13, y: 1, items: 8, maxItems: 10, type: 'drinks', color: '#e0f7fa', price: 160, label: 'È£≤Êñô' },
            { x: 13, y: 2, items: 7, maxItems: 10, type: 'drinks', color: '#e0f7fa', price: 140, label: 'È£≤Êñô' },

            // Coffee machine (X=13)
            { x: 13, y: 4, items: 10, maxItems: 10, type: 'coffee', color: '#8b7355', price: 100, label: '„Ç≥„Éº„Éí„Éº' },

            // Center gondola shelves
            { x: 4, y: 2, items: 8, maxItems: 10, type: 'bread', color: '#ffe4b5', price: 120, label: '„Éë„É≥' },
            { x: 6, y: 2, items: 7, maxItems: 10, type: 'bread', color: '#ffe4b5', price: 150, label: '„Éë„É≥' },
            { x: 8, y: 2, items: 9, maxItems: 10, type: 'bread', color: '#ffe4b5', price: 130, label: '„Éë„É≥' },

            { x: 4, y: 4, items: 8, maxItems: 10, type: 'snacks', color: '#fff176', price: 200, label: '„ÅäËèìÂ≠ê' },
            { x: 6, y: 4, items: 6, maxItems: 10, type: 'snacks', color: '#fff176', price: 180, label: '„ÅäËèìÂ≠ê' },
            { x: 8, y: 4, items: 7, maxItems: 10, type: 'snacks', color: '#fff176', price: 220, label: '„ÅäËèìÂ≠ê' },

            { x: 4, y: 6, items: 5, maxItems: 10, type: 'noodles', color: '#ffcc80', price: 200, label: '„Ç´„ÉÉ„ÉóÈ∫∫' },
            { x: 6, y: 6, items: 6, maxItems: 10, type: 'noodles', color: '#ffcc80', price: 180, label: '„Ç´„ÉÉ„ÉóÈ∫∫' },
            { x: 8, y: 6, items: 7, maxItems: 10, type: 'noodles', color: '#ffcc80', price: 250, label: '„Ç´„ÉÉ„ÉóÈ∫∫' },

            // Frozen section (left front)
            { x: 1, y: 7, items: 6, maxItems: 10, type: 'frozen', color: '#b3e5fc', price: 300, label: 'ÂÜ∑Âáç' },
            { x: 1, y: 8, items: 5, maxItems: 10, type: 'frozen', color: '#b3e5fc', price: 350, label: 'ÂÜ∑Âáç' },

            // Hot food counter (near register)
            { x: 12, y: 7, items: 5, maxItems: 10, type: 'hot', color: '#ff8a65', price: 220, label: '„Éõ„ÉÉ„Éà' },
        ];

        // Game stats
        let totalSales = 0;
        let customersServed = 0;
        const sparkles = [];

        // ============================================
        // CUSTOMER SYSTEM
        // ============================================

        const customers = [];
        let lastCustomerTime = Date.now();
        const CUSTOMER_INTERVAL = 5000;
        const MAX_CUSTOMERS = 4;
        const CUSTOMER_COLORS = ['#e8b4b8', '#b4d4e8', '#d4e8b4', '#e8d4b4', '#d4b4e8'];

        const SHELF_TYPES = ['drinks', 'snacks', 'bento', 'onigiri', 'bread', 'frozen', 'noodles', 'hot', 'coffee'];

        function spawnCustomer() {
            const itemsToBuy = 1 + Math.floor(Math.random() * 3);
            const shoppingList = [];
            for (let i = 0; i < itemsToBuy; i++) {
                shoppingList.push(SHELF_TYPES[Math.floor(Math.random() * SHELF_TYPES.length)]);
            }

            const customer = {
                x: entranceX,
                y: entranceY,
                targetX: entranceX,
                targetY: entranceY - 1,
                color: CUSTOMER_COLORS[Math.floor(Math.random() * CUSTOMER_COLORS.length)],
                state: 'entering',
                shoppingList,
                cart: [],
                currentShopIndex: 0,
                moveTimer: 0,
                grabTimer: 0,
                waitTime: 0
            };
            customers.push(customer);
            playDoorChime();
        }

        function getShelfByType(type) {
            // Find a shelf of this type that has items
            const available = shelves.filter(s => s.type === type && s.items > 0);
            if (available.length > 0) {
                return available[Math.floor(Math.random() * available.length)];
            }
            return shelves.find(s => s.type === type);
        }

        function updateCustomers() {
            const now = Date.now();

            if (now - lastCustomerTime > CUSTOMER_INTERVAL && customers.length < MAX_CUSTOMERS) {
                spawnCustomer();
                lastCustomerTime = now;
            }

            customers.forEach((c, index) => {
                if (now - c.moveTimer < 300) return;
                c.moveTimer = now;

                switch (c.state) {
                    case 'entering':
                        if (c.y > entranceY - 2) {
                            c.y--;
                        } else {
                            c.state = 'shopping';
                            setNextShoppingTarget(c);
                        }
                        break;

                    case 'shopping':
                        if (moveToward(c, c.targetX, c.targetY)) {
                            c.state = 'grabbing';
                            c.grabTimer = now;
                        }
                        break;

                    case 'grabbing':
                        if (now - c.grabTimer > 700) {
                            const wantType = c.shoppingList[c.currentShopIndex];
                            const shelf = getShelfByType(wantType);

                            if (shelf && shelf.items > 0) {
                                shelf.items--;
                                c.cart.push({ type: wantType, price: shelf.price });
                                playGrab();
                            }

                            c.currentShopIndex++;

                            if (c.currentShopIndex < c.shoppingList.length) {
                                c.state = 'shopping';
                                setNextShoppingTarget(c);
                            } else {
                                c.state = 'to_register';
                                c.targetX = register.x - 1;
                                c.targetY = register.y;
                            }
                        }
                        break;

                    case 'to_register':
                        if (moveToward(c, c.targetX, c.targetY)) {
                            c.state = 'waiting';
                            c.waitTime = now;
                        }
                        break;

                    case 'waiting':
                        break;

                    case 'leaving':
                        // Head to entrance then exit
                        if (c.y < entranceY) {
                            c.y++;
                        } else if (c.x !== entranceX) {
                            c.x += c.x < entranceX ? 1 : -1;
                        } else {
                            customers.splice(index, 1);
                        }
                        break;
                }
            });
        }

        function setNextShoppingTarget(customer) {
            const wantType = customer.shoppingList[customer.currentShopIndex];
            const shelf = getShelfByType(wantType);
            if (shelf) {
                // Stand adjacent to shelf
                customer.targetX = shelf.x;
                customer.targetY = shelf.y + 1;
                // Keep in bounds
                if (customer.targetY >= GRID_H - 1) customer.targetY = shelf.y - 1;
            }
        }

        function moveToward(entity, targetX, targetY) {
            // Simple pathfinding - avoid shelves
            const dx = targetX - entity.x;
            const dy = targetY - entity.y;

            if (dx !== 0) {
                const newX = entity.x + Math.sign(dx);
                if (!isBlocked(newX, entity.y)) {
                    entity.x = newX;
                    return false;
                }
            }
            if (dy !== 0) {
                const newY = entity.y + Math.sign(dy);
                if (!isBlocked(entity.x, newY)) {
                    entity.y = newY;
                    return false;
                }
            }
            // Try alternate directions
            if (dy !== 0) {
                const newY = entity.y + Math.sign(dy);
                if (!isBlocked(entity.x, newY)) {
                    entity.y = newY;
                    return false;
                }
            }
            if (dx !== 0) {
                const newX = entity.x + Math.sign(dx);
                if (!isBlocked(newX, entity.y)) {
                    entity.x = newX;
                    return false;
                }
            }

            return entity.x === targetX && entity.y === targetY;
        }

        function isBlocked(x, y) {
            if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return true;
            if (shelves.some(s => s.x === x && s.y === y)) return true;
            if (x === register.x && y === register.y) return true;
            return false;
        }

        function checkoutCustomer() {
            const waiting = customers.find(c =>
                c.state === 'waiting' &&
                Math.abs(c.x - player.x) <= 1 &&
                Math.abs(c.y - player.y) <= 1
            );

            if (waiting && waiting.cart.length > 0) {
                const total = waiting.cart.reduce((sum, item) => sum + item.price, 0);
                totalSales += total;
                customersServed++;
                playCashRegister();

                for (let i = 0; i < 10; i++) {
                    sparkles.push({
                        x: (waiting.x + 0.5) * TILE_SIZE,
                        y: (waiting.y + 0.5) * TILE_SIZE,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 1,
                        color: '#ffd700'
                    });
                }

                waiting.state = 'leaving';
                return true;
            }
            return false;
        }

        // ============================================
        // INPUT HANDLING
        // ============================================

        const keys = {};
        let lastActionTime = 0, lastMoveTime = 0;

        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyM') {
                e.preventDefault();
                toggleMusic();
                updateMusicButton();
                return;
            }
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyE', 'Space'].includes(e.code)) {
                e.preventDefault();
                initAudio();
                keys[e.code] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // ============================================
        // GAMEPAD (PS5 CONTROLLER) SUPPORT
        // ============================================

        const gamepadState = {
            up: false,
            down: false,
            left: false,
            right: false,
            action: false,   // X button - checkout/stock
            pickup: false    // Square button - pickup from stockroom
        };

        const STICK_DEADZONE = 0.3;
        let lastMusicToggle = 0;
        const controllerStatusEl = document.getElementById('controllerStatus');

        window.addEventListener('gamepadconnected', (e) => {
            controllerStatusEl.textContent = `üéÆ ${e.gamepad.id.split('(')[0].trim()}`;
            controllerStatusEl.style.color = '#6bcb77';
            initAudio();
        });

        window.addEventListener('gamepaddisconnected', () => {
            controllerStatusEl.textContent = '';
        });

        function pollGamepad() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];

            for (const gp of gamepads) {
                if (!gp) continue;

                // PS5 DualSense: 0=Cross, 2=Square, 9=Options
                // D-pad: 12=Up, 13=Down, 14=Left, 15=Right
                // Axes: 0=LeftStickX, 1=LeftStickY

                const leftStickX = gp.axes[0] || 0;
                const leftStickY = gp.axes[1] || 0;

                gamepadState.up = gp.buttons[12]?.pressed || leftStickY < -STICK_DEADZONE;
                gamepadState.down = gp.buttons[13]?.pressed || leftStickY > STICK_DEADZONE;
                gamepadState.left = gp.buttons[14]?.pressed || leftStickX < -STICK_DEADZONE;
                gamepadState.right = gp.buttons[15]?.pressed || leftStickX > STICK_DEADZONE;

                gamepadState.action = gp.buttons[0]?.pressed;  // Cross (X)
                gamepadState.pickup = gp.buttons[2]?.pressed;  // Square

                // Options button for music toggle (with debounce)
                const now = Date.now();
                if (gp.buttons[9]?.pressed && now - lastMusicToggle > 500) {
                    toggleMusic();
                    updateMusicButton();
                    lastMusicToggle = now;
                }

                if (gamepadState.action || gamepadState.pickup) {
                    initAudio();
                }

                break;
            }
        }

        function gameLoop() {
            const now = Date.now();

            // Poll gamepad
            pollGamepad();

            updateCustomers();

            // Movement (keyboard or gamepad)
            if (now - lastMoveTime >= 150) {
                if (keys['ArrowUp'] || gamepadState.up) { move(0, -1); lastMoveTime = now; }
                else if (keys['ArrowDown'] || gamepadState.down) { move(0, 1); lastMoveTime = now; }
                else if (keys['ArrowLeft'] || gamepadState.left) { move(-1, 0); lastMoveTime = now; }
                else if (keys['ArrowRight'] || gamepadState.right) { move(1, 0); lastMoveTime = now; }
            }

            // Actions (keyboard or gamepad)
            if (now - lastActionTime >= 150) {
                if (keys['KeyE'] || gamepadState.action) { interact(); lastActionTime = now; }
                else if (keys['Space'] || gamepadState.pickup) { pickupStock(); lastActionTime = now; }
            }

            requestAnimationFrame(gameLoop);
        }

        function move(dx, dy) {
            const nx = player.x + dx;
            const ny = player.y + dy;
            if (!isBlocked(nx, ny)) {
                player.x = nx;
                player.y = ny;
            }
            updateStatus();
        }

        function interact() {
            if (checkoutCustomer()) {
                updateStatus();
                return;
            }

            const adjacent = shelves.find(s =>
                Math.abs(s.x - player.x) + Math.abs(s.y - player.y) === 1
            );

            if (adjacent && player.holding > 0 && adjacent.items < adjacent.maxItems) {
                adjacent.items++;
                player.holding--;
                playShelfTone(adjacent.items);

                if (adjacent.items >= adjacent.maxItems) {
                    playComplete();
                    for (let i = 0; i < 8; i++) {
                        sparkles.push({
                            x: (adjacent.x + 0.5) * TILE_SIZE,
                            y: (adjacent.y + 0.5) * TILE_SIZE,
                            vx: (Math.random() - 0.5) * 5,
                            vy: (Math.random() - 0.5) * 5,
                            life: 1,
                            color: '#4caf50'
                        });
                    }
                }
            }
            updateStatus();
        }

        function pickupStock() {
            // Stockroom is in top-left corner (Y=0-1, X=0-1)
            if (player.x <= 1 && player.y <= 1 && player.holding < player.maxHold) {
                player.holding++;
                playPickup();
            }
            updateStatus();
        }

        function updateStatus() {
            const waiting = customers.filter(c => c.state === 'waiting').length;
            const lowStock = shelves.filter(s => s.items <= 2).length;

            let status = `üí¥ ¬•${totalSales.toLocaleString()} | üë• ${customersServed}`;
            if (waiting > 0) status += ` | ‚è≥ ${waiting}`;
            if (lowStock > 0) status += ` | ‚ö†Ô∏è ${lowStock}`;
            if (player.holding > 0) status += ` | üì¶ ${player.holding}`;

            statusEl.textContent = status;
        }

        // ============================================
        // RENDERING
        // ============================================

        function draw() {
            // Floor
            ctx.fillStyle = '#f8f4e8';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Tile pattern
            for (let y = 0; y < GRID_H; y++) {
                for (let x = 0; x < GRID_W; x++) {
                    ctx.fillStyle = (x + y) % 2 === 0 ? '#f0ece0' : '#f8f4e8';
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // Grid lines (subtle)
            ctx.strokeStyle = '#e0dcd0';
            ctx.lineWidth = 1;
            for (let x = 0; x <= GRID_W; x++) {
                ctx.beginPath();
                ctx.moveTo(x * TILE_SIZE, 0);
                ctx.lineTo(x * TILE_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= GRID_H; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * TILE_SIZE);
                ctx.lineTo(canvas.width, y * TILE_SIZE);
                ctx.stroke();
            }

            // Stockroom area (top-left)
            ctx.fillStyle = '#d4c8b8';
            ctx.fillRect(0, 0, TILE_SIZE * 2, TILE_SIZE * 2);
            ctx.fillStyle = '#a08060';
            ctx.fillRect(10, 10, 70, 50);
            ctx.fillRect(10, 70, 70, 50);
            ctx.fillStyle = '#8b7355';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('üì¶', TILE_SIZE, TILE_SIZE * 0.6);
            ctx.font = '9px sans-serif';
            ctx.fillText('STOCK', TILE_SIZE, TILE_SIZE * 1.5);

            // Entrance (bottom center)
            const ex = entranceX * TILE_SIZE;
            const ey = entranceY * TILE_SIZE;
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(ex - TILE_SIZE, ey, TILE_SIZE * 3, TILE_SIZE);
            ctx.fillStyle = '#5ba3c0';
            ctx.fillRect(ex - TILE_SIZE, ey, TILE_SIZE * 3, 6);
            // Automatic door lines
            ctx.strokeStyle = '#4a90a4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(ex + TILE_SIZE * 0.5, ey + 10);
            ctx.lineTo(ex + TILE_SIZE * 0.5, ey + TILE_SIZE - 5);
            ctx.stroke();
            ctx.fillStyle = '#2c5f6e';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('üö™ ENTRANCE', ex + TILE_SIZE * 0.5, ey + TILE_SIZE/2 + 12);

            // Register
            const rx = register.x * TILE_SIZE;
            const ry = register.y * TILE_SIZE;
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(rx + 2, ry + 2, TILE_SIZE - 4, TILE_SIZE - 4);
            ctx.fillStyle = '#D2691E';
            ctx.fillRect(rx + 6, ry + 6, TILE_SIZE - 12, TILE_SIZE - 16);
            // POS screen
            ctx.fillStyle = '#333';
            ctx.fillRect(rx + 10, ry + 8, TILE_SIZE - 20, 14);
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(rx + 12, ry + 10, TILE_SIZE - 24, 10);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 8px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('¬•', rx + TILE_SIZE/2, ry + 18);
            ctx.fillStyle = '#333';
            ctx.font = '8px sans-serif';
            ctx.fillText('REGISTER', rx + TILE_SIZE/2, ry + TILE_SIZE - 6);

            // Shelves
            shelves.forEach(shelf => {
                const sx = shelf.x * TILE_SIZE;
                const sy = shelf.y * TILE_SIZE;
                const fillRatio = shelf.items / shelf.maxItems;

                // Get sprite
                let img = null;
                switch(shelf.type) {
                    case 'drinks': img = assets.shelfDrinks; break;
                    case 'snacks': img = assets.shelfSnacks; break;
                    case 'bento': img = assets.shelfBento; break;
                    case 'onigiri': img = assets.shelfOnigiri; break;
                    case 'hot': img = assets.shelfHot; break;
                    case 'coffee': img = assets.shelfCoffee; break;
                    case 'bread': img = assets.shelfBread; break;
                    case 'noodles': img = assets.shelfNoodles; break;
                    case 'frozen': img = assets.shelfFrozen; break;
                }

                // Low stock warning glow
                if (shelf.items <= 2) {
                    ctx.shadowColor = '#ff4444';
                    ctx.shadowBlur = 8 + Math.sin(Date.now() / 150) * 4;
                }

                if (img) {
                    ctx.globalAlpha = 0.4 + fillRatio * 0.6;
                    ctx.drawImage(img, sx - 12, sy - 12, TILE_SIZE + 24, TILE_SIZE + 24);
                    ctx.globalAlpha = 1;
                } else {
                    ctx.fillStyle = shelf.color;
                    ctx.globalAlpha = 0.4 + fillRatio * 0.6;
                    ctx.fillRect(sx + 4, sy + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                    ctx.globalAlpha = 1;
                }

                ctx.shadowBlur = 0;

                // Stock count badge
                const isLow = shelf.items <= 2;
                ctx.fillStyle = isLow ? '#e53935' : 'rgba(0,0,0,0.7)';
                ctx.beginPath();
                ctx.roundRect(sx + TILE_SIZE/2 - 14, sy + TILE_SIZE - 14, 28, 14, 3);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`${shelf.items}`, sx + TILE_SIZE/2, sy + TILE_SIZE - 4);

                // Price tag (above shelf)
                ctx.fillStyle = '#4CAF50';
                ctx.font = '9px sans-serif';
                ctx.fillText(`¬•${shelf.price}`, sx + TILE_SIZE/2, sy - 2);
            });

            ctx.textAlign = 'left';

            // Player
            const px = player.x * TILE_SIZE;
            const py = player.y * TILE_SIZE;

            if (assets.player) {
                ctx.drawImage(assets.player, px - 4, py - 12, TILE_SIZE + 8, TILE_SIZE + 12);
            } else {
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, TILE_SIZE/3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Held items
            if (player.holding > 0) {
                const cx = px + TILE_SIZE/2;
                for (let i = 0; i < player.holding; i++) {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(cx - 8, py - 16 - i * 6, 16, 5);
                    ctx.strokeStyle = '#5D3A1A';
                    ctx.strokeRect(cx - 8, py - 16 - i * 6, 16, 5);
                }
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(cx + 14, py - 8, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(player.holding.toString(), cx + 14, py - 4);
                ctx.textAlign = 'left';
            }

            // Customers
            customers.forEach(c => {
                const cx = c.x * TILE_SIZE + TILE_SIZE/2;
                const cy = c.y * TILE_SIZE + TILE_SIZE/2;

                if (assets.customer) {
                    const imgW = assets.customer.width / 3;
                    ctx.drawImage(assets.customer, imgW, 0, imgW, assets.customer.height,
                        c.x * TILE_SIZE, c.y * TILE_SIZE - 8, TILE_SIZE, TILE_SIZE + 8);
                } else {
                    ctx.fillStyle = c.color;
                    ctx.beginPath();
                    ctx.arc(cx, cy, TILE_SIZE/4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Shopping basket
                if (c.cart.length > 0 || c.state === 'shopping' || c.state === 'grabbing') {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(cx - 10, cy + 14, 20, 12);
                    if (c.cart.length > 0) {
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.arc(cx + 6, cy + 12, 7, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 8px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(c.cart.length.toString(), cx + 6, cy + 15);
                    }
                }

                // Thought bubble
                if (c.state === 'shopping' || c.state === 'grabbing') {
                    const want = c.shoppingList[c.currentShopIndex];
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.ellipse(cx + 18, cy - 28, 16, 11, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    const emoji = {
                        drinks: 'ü•§', snacks: 'üç™', bento: 'üç±', onigiri: 'üçô',
                        bread: 'üçû', frozen: 'üßä', noodles: 'üçú', hot: 'üçó', coffee: '‚òï'
                    }[want] || '‚ùì';
                    ctx.font = '11px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(emoji, cx + 18, cy - 25);
                }

                // Waiting at register
                if (c.state === 'waiting') {
                    const wait = (Date.now() - c.waitTime) / 1000;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.ellipse(cx + 18, cy - 28, 16, 11, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = wait > 5 ? '#e53935' : '#333';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(wait > 5 ? 'üò§' : 'üí¥', cx + 18, cy - 25);
                }

                // Leaving happy
                if (c.state === 'leaving') {
                    ctx.font = '16px sans-serif';
                    ctx.fillText('üòä', cx - 8, cy - 22);
                }

                ctx.textAlign = 'left';
            });

            // Sparkles
            for (let i = sparkles.length - 1; i >= 0; i--) {
                const s = sparkles[i];
                ctx.fillStyle = s.color;
                ctx.globalAlpha = s.life;
                ctx.beginPath();
                ctx.arc(s.x, s.y, 4 * s.life, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                s.x += s.vx;
                s.y += s.vy;
                s.life -= 0.025;
                if (s.life <= 0) sparkles.splice(i, 1);
            }

            requestAnimationFrame(draw);
        }

        // Start
        async function init() {
            await loadAssets();
            console.log('„Ç≥„É≥„Éì„Éã Master v9.0 - Authentic Konbini Layout!');
            gameLoop();
            draw();
            updateStatus();
        }
        init();
    </script>
</body>
</html>
